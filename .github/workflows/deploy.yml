name: Deploy to Elastic Beanstalk

on:
  push:
    branches:
      - dev
      - qa
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.ref_name == 'main' && 'prod' || github.ref_name }}
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Configure AWS credentials for Dev
        if: ${{ github.ref == 'refs/heads/dev' }}
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME_DEV }}
          aws-region: us-east-1

      - name: Configure AWS credentials for QA
        if: ${{ github.ref == 'refs/heads/qa' }}
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME_QA }}
          aws-region: us-east-1

      - name: Configure AWS credentials for Prod
        if: ${{ github.ref == 'refs/heads/main' }}
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME_PROD }}
          aws-region: us-east-1

      - name: Set variables
        run: |
          BRANCH=${GITHUB_REF##*/}
          if [[ "$BRANCH" == "main" ]]; then ENV=prod; else ENV=$BRANCH; fi
          STACK_NAME="MetadataOnboarding-${ENV}"
          
          # Extract application name from parameters file for dynamic bucket naming
          APP_NAME=$(jq -r '.Parameters.ApplicationName' infra/parameters/${ENV}-parameters.json)
          APP_NAME_BASE=$(echo $APP_NAME | sed 's/-dev$\|-qa$\|-prod$//')
          
          S3_BUCKET="${APP_NAME_BASE}-eb-artifacts-${ENV}"
          CFN_BUCKET="${APP_NAME_BASE}-cfn-artifacts-${ENV}"
          
          echo "ENV=$ENV" >> $GITHUB_ENV
          echo "STACK_NAME=$STACK_NAME" >> $GITHUB_ENV
          echo "EB_S3_BUCKET=$S3_BUCKET" >> $GITHUB_ENV
          echo "CFN_BUCKET=$CFN_BUCKET" >> $GITHUB_ENV

      - name: Clean up existing EB environments
        run: |
          # Check if our environment already exists, but keep the application
          APP_NAME=$(jq -r '.Parameters.ApplicationName' infra/parameters/${ENV}-parameters.json)
          ENV_NAME=$(jq -r '.Parameters.EnvironmentName' infra/parameters/${ENV}-parameters.json)
          
          echo "Checking if environment '$ENV_NAME' exists..."
          
          # Try to terminate the environment if it exists
          if aws elasticbeanstalk describe-environments --application-name $APP_NAME --environment-names $ENV_NAME --include-deleted=false 2>/dev/null | jq -e '.Environments[0]' > /dev/null; then
            echo "Environment '$ENV_NAME' exists. Terminating it..."
            aws elasticbeanstalk terminate-environment --environment-name $ENV_NAME
            echo "Waiting 45 seconds for environment termination to complete..."
            sleep 45
          else
            echo "Environment '$ENV_NAME' does not exist or cannot be accessed."
          fi

      - name: Create S3 buckets
        run: |
          # Create EB artifacts bucket first
          aws s3 mb s3://${EB_S3_BUCKET} || true
          # Create CloudFormation artifacts bucket
          aws s3 mb s3://${CFN_BUCKET} || true

      - name: Archive and Upload Application
        run: |
          # Create unique version identifier using timestamp and commit hash
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          COMMIT_HASH=$(git rev-parse --short HEAD)
          VERSION_LABEL="v${TIMESTAMP}-${COMMIT_HASH}"
          S3_KEY="app-${VERSION_LABEL}.zip"
          
          # Create versioned zip file directly (include sample files that were previously excluded)
          zip -r ${S3_KEY} . \
            -x ".git*" \
            -x ".github/*" \
            -x ".flake8" \
            -x ".gitignore" \
            -x "README.md" \
            -x "Sample_Files/*" \
            -x "infra/*" \
            -x "tests/*" \
          
          # Upload the application bundle to S3 with version in filename
          aws s3 cp ${S3_KEY} s3://${EB_S3_BUCKET}/${S3_KEY}
          
          # Save the app version label and S3 key for later use
          echo "VERSION_LABEL=${VERSION_LABEL}" >> $GITHUB_ENV
          echo "S3_KEY=${S3_KEY}" >> $GITHUB_ENV

      - name: Create Elastic Beanstalk Application
        run: |
          # Extract application name from parameters
          APP_NAME=$(jq -r '.Parameters.ApplicationName' infra/parameters/${ENV}-parameters.json)
          
          # First, create the application (this is required before creating a version)
          echo "Creating application '$APP_NAME'..."
          aws elasticbeanstalk create-application \
            --application-name ${APP_NAME} \
            --description "Created from GitHub Actions on $(date)" \
            || echo "Application may already exist or will be created by CloudFormation"
            
          # Now create the application version after ensuring the application exists
          echo "Creating application version '${VERSION_LABEL}'..."
          aws elasticbeanstalk create-application-version \
            --application-name ${APP_NAME} \
            --version-label ${VERSION_LABEL} \
            --description "Deployed from GitHub Actions on $(date)" \
            --source-bundle S3Bucket=${EB_S3_BUCKET},S3Key=${S3_KEY} \
            --process
            
          # Verify that the version was created successfully
          echo "Verifying application version exists..."
          aws elasticbeanstalk describe-application-versions \
            --application-name ${APP_NAME} \
            --version-labels ${VERSION_LABEL}

      - name: Set CloudFormation parameters
        run: |
          # Extract parameters from JSON file directly
          APP_NAME=$(jq -r '.Parameters.ApplicationName' infra/parameters/${ENV}-parameters.json)
          ENV_NAME=$(jq -r '.Parameters.EnvironmentName' infra/parameters/${ENV}-parameters.json)
          INSTANCE_TYPE=$(jq -r '.Parameters.InstanceType' infra/parameters/${ENV}-parameters.json)
          KEY_NAME=$(jq -r '.Parameters.KeyName' infra/parameters/${ENV}-parameters.json)
          SOLUTION_STACK=$(jq -r '.Parameters.SolutionStackName' infra/parameters/${ENV}-parameters.json)
          echo "APP_NAME=$APP_NAME" >> $GITHUB_ENV
          echo "ENV_NAME=$ENV_NAME" >> $GITHUB_ENV
          echo "INSTANCE_TYPE=$INSTANCE_TYPE" >> $GITHUB_ENV
          echo "KEY_NAME=$KEY_NAME" >> $GITHUB_ENV
          echo "SOLUTION_STACK=$SOLUTION_STACK" >> $GITHUB_ENV

      - name: Deploy with direct CloudFormation template
        run: |
          # Instead of using packaging, create a temporary direct template that won't be transformed
          cat <<- EOF > direct-template.yaml
AWSTemplateFormatVersion: '2010-09-09'
Description: Elastic Beanstalk deployment stack for Data Onboarding Framework

Parameters:
  ApplicationName:
    Type: String
    Default: dataonboardingapp
  EnvironmentName:
    Type: String
    Default: DataOnboardingEnv
  InstanceType:
    Type: String
    Default: t3.small
  KeyName:
    Type: AWS::EC2::KeyPair::KeyName
  DeployEnvironment:
    Type: String
    Default: dev
  SolutionStackName:
    Type: String
    Default: "64bit Amazon Linux 2023 v4.5.1 running Python 3.11"
  SourceBundleKey:
    Type: String
    Default: app.zip
  VersionLabel:
    Type: String
    Default: "initial-version"

Resources:
  ServiceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: [ec2.amazonaws.com]
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AWSElasticBeanstalkWebTier
        - arn:aws:iam::aws:policy/AWSElasticBeanstalkWorkerTier
        - arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess

  InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles: [ !Ref ServiceRole ]

  Environment:
    Type: AWS::ElasticBeanstalk::Environment
    Properties:
      ApplicationName: !Ref ApplicationName
      EnvironmentName: !Ref EnvironmentName
      SolutionStackName: !Ref SolutionStackName
      VersionLabel: !Ref VersionLabel
      OptionSettings:
        - Namespace: aws:autoscaling:launchconfiguration
          OptionName: InstanceType
          Value: !Ref InstanceType
        - Namespace: aws:elasticbeanstalk:environment
          OptionName: EnvironmentType
          Value: LoadBalanced
        - Namespace: aws:elasticbeanstalk:environment
          OptionName: LoadBalancerType
          Value: application
        - Namespace: aws:autoscaling:launchconfiguration
          OptionName: IamInstanceProfile
          Value: !Ref InstanceProfile
        - Namespace: aws:elasticbeanstalk:application:environment
          OptionName: LOG_FILE
          Value: /var/log/app.log
        - Namespace: aws:elasticbeanstalk:application:environment
          OptionName: PORT
          Value: 8000

Outputs:
  EnvURL:
    Value: !GetAtt Environment.EndpointURL
  EnvironmentName:
    Description: "Elastic Beanstalk environment name"
    Value: !Ref EnvironmentName
EOF
          
          # Deploy directly with the new template
          aws cloudformation deploy \
            --template-file direct-template.yaml \
            --stack-name ${STACK_NAME} \
            --parameter-overrides \
              ApplicationName=${APP_NAME} \
              EnvironmentName=${ENV_NAME} \
              InstanceType=${INSTANCE_TYPE} \
              KeyName=${KEY_NAME} \
              DeployEnvironment=${ENV} \
              SolutionStackName="${SOLUTION_STACK}" \
              SourceBundleKey=${S3_KEY} \
              VersionLabel=${VERSION_LABEL} \
            --capabilities CAPABILITY_NAMED_IAM \
            --no-fail-on-empty-changeset