name: Deploy to Elastic Beanstalk

on:
  push:
    branches:
      - dev
      - qa
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.ref_name == 'main' && 'prod' || github.ref_name }}
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Configure AWS credentials for Dev
        if: ${{ github.ref == 'refs/heads/dev' }}
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME_DEV }}
          aws-region: us-east-1

      - name: Configure AWS credentials for QA
        if: ${{ github.ref == 'refs/heads/qa' }}
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME_QA }}
          aws-region: us-east-1

      - name: Configure AWS credentials for Prod
        if: ${{ github.ref == 'refs/heads/main' }}
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME_PROD }}
          aws-region: us-east-1

      - name: Set variables
        run: |
          BRANCH=${GITHUB_REF##*/}
          if [[ "$BRANCH" == "main" ]]; then ENV=prod; else ENV=$BRANCH; fi
          STACK_NAME="MetadataOnboarding-${ENV}"
          
          # Extract application name from parameters file for dynamic bucket naming
          APP_NAME=$(jq -r '.Parameters.ApplicationName' infra/parameters/${ENV}-parameters.json)
          APP_NAME_BASE=$(echo $APP_NAME | sed 's/-dev$\|-qa$\|-prod$//')
          
          S3_BUCKET="${APP_NAME_BASE}-eb-artifacts-${ENV}"
          CFN_BUCKET="${APP_NAME_BASE}-cfn-artifacts-${ENV}"
          
          echo "ENV=$ENV" >> $GITHUB_ENV
          echo "STACK_NAME=$STACK_NAME" >> $GITHUB_ENV
          echo "EB_S3_BUCKET=$S3_BUCKET" >> $GITHUB_ENV
          echo "CFN_BUCKET=$CFN_BUCKET" >> $GITHUB_ENV

      - name: Clean up existing EB applications
        run: |
          # Check if our application already exists
          APP_NAME=$(jq -r '.Parameters.ApplicationName' infra/parameters/${ENV}-parameters.json)
          echo "Checking if application '$APP_NAME' exists..."
          
          # Try to get the application
          if aws elasticbeanstalk describe-applications --application-names $APP_NAME 2>/dev/null; then
            echo "Application '$APP_NAME' exists. Deleting it..."
            # Delete the application if it exists
            aws elasticbeanstalk delete-application --application-name $APP_NAME --terminate-env-by-force
            # Wait to ensure it's fully deleted (AWS sometimes needs time)
            echo "Waiting 30 seconds for application deletion to complete..."
            sleep 30
          else
            echo "Application '$APP_NAME' does not exist or cannot be accessed."
          fi
          
          # Also check the old application name
          if aws elasticbeanstalk describe-applications --application-names dataonboardingapp 2>/dev/null; then
            echo "Old application 'dataonboardingapp' exists. Deleting it..."
            aws elasticbeanstalk delete-application --application-name dataonboardingapp --terminate-env-by-force
            echo "Waiting 30 seconds for old application deletion to complete..."
            sleep 30
          else
            echo "Old application 'dataonboardingapp' does not exist or cannot be accessed."
          fi

      - name: Create S3 buckets
        run: |
          # Create EB artifacts bucket first
          aws s3 mb s3://${EB_S3_BUCKET} || true
          # Create CloudFormation artifacts bucket
          aws s3 mb s3://${CFN_BUCKET} || true

      - name: Archive and Upload Application
        run: |
          # Create unique version identifier using timestamp and commit hash
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          COMMIT_HASH=$(git rev-parse --short HEAD)
          VERSION_LABEL="v${TIMESTAMP}-${COMMIT_HASH}"
          S3_KEY="app-${VERSION_LABEL}.zip"
          
          # Create versioned zip file directly (include sample files that were previously excluded)
          zip -r ${S3_KEY} . \
            -x ".git*" \
            -x ".github/*" \
            -x ".flake8" \
            -x ".gitignore" \
            -x "README.md" \
            -x "Sample_Files/*" \
            -x "infra/*" \
            -x "tests/*" \
          
          # Upload the application bundle to S3 with version in filename
          aws s3 cp ${S3_KEY} s3://${EB_S3_BUCKET}/${S3_KEY}
          
          # Save the app version label and S3 key for later use
          echo "VERSION_LABEL=${VERSION_LABEL}" >> $GITHUB_ENV
          echo "S3_KEY=${S3_KEY}" >> $GITHUB_ENV

      - name: Create Elastic Beanstalk Application
        run: |
          # Extract application name from parameters
          APP_NAME=$(jq -r '.Parameters.ApplicationName' infra/parameters/${ENV}-parameters.json)
          
          # First, create the application (this is required before creating a version)
          echo "Creating application '$APP_NAME'..."
          aws elasticbeanstalk create-application \
            --application-name ${APP_NAME} \
            --description "Created from GitHub Actions on $(date)" \
            || echo "Application may already exist or will be created by CloudFormation"
            
          # Now create the application version after ensuring the application exists
          echo "Creating application version '${VERSION_LABEL}'..."
          aws elasticbeanstalk create-application-version \
            --application-name ${APP_NAME} \
            --version-label ${VERSION_LABEL} \
            --description "Deployed from GitHub Actions on $(date)" \
            --source-bundle S3Bucket=${EB_S3_BUCKET},S3Key=${S3_KEY} \
            --process
            
          # Verify that the version was created successfully
          echo "Verifying application version exists..."
          aws elasticbeanstalk describe-application-versions \
            --application-name ${APP_NAME} \
            --version-labels ${VERSION_LABEL}

      - name: Set CloudFormation parameters
        run: |
          # Extract parameters from JSON file directly
          APP_NAME=$(jq -r '.Parameters.ApplicationName' infra/parameters/${ENV}-parameters.json)
          ENV_NAME=$(jq -r '.Parameters.EnvironmentName' infra/parameters/${ENV}-parameters.json)
          INSTANCE_TYPE=$(jq -r '.Parameters.InstanceType' infra/parameters/${ENV}-parameters.json)
          KEY_NAME=$(jq -r '.Parameters.KeyName' infra/parameters/${ENV}-parameters.json)
          SOLUTION_STACK=$(jq -r '.Parameters.SolutionStackName' infra/parameters/${ENV}-parameters.json)
          echo "APP_NAME=$APP_NAME" >> $GITHUB_ENV
          echo "ENV_NAME=$ENV_NAME" >> $GITHUB_ENV
          echo "INSTANCE_TYPE=$INSTANCE_TYPE" >> $GITHUB_ENV
          echo "KEY_NAME=$KEY_NAME" >> $GITHUB_ENV
          echo "SOLUTION_STACK=$SOLUTION_STACK" >> $GITHUB_ENV

      - name: Package CloudFormation
        run: |
          aws cloudformation package \
            --template-file infra/cloudformation.yaml \
            --s3-bucket ${CFN_BUCKET} \
            --output-template-file packaged.yaml

      - name: Deploy CloudFormation stack
        run: |
          aws cloudformation deploy \
            --template-file packaged.yaml \
            --stack-name ${STACK_NAME} \
            --parameter-overrides \
              ApplicationName=${APP_NAME} \
              EnvironmentName=${ENV_NAME} \
              InstanceType=${INSTANCE_TYPE} \
              KeyName=${KEY_NAME} \
              DeployEnvironment=${ENV} \
              SolutionStackName="${SOLUTION_STACK}" \
              SourceBundleKey=${S3_KEY} \
              VersionLabel=${VERSION_LABEL} \
              CreateS3Bucket='false' \
            --capabilities CAPABILITY_NAMED_IAM \
            --no-fail-on-empty-changeset